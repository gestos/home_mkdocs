{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hi This is a blog-to-be, mainly to fiddle a bit with mkdocs because a static-site-generator seems like a nice thing. apart from the fiddling, it's meant to be a personal homepage for me. my real name is known to those whom it concerns ;) a legal notice (german: \"impressum\", which is mandatory here) will follow soon. I guess. This is/was the default vanilla mkdocs index page: Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"gestos/work in progress"},{"location":"#hi","text":"This is a blog-to-be, mainly to fiddle a bit with mkdocs because a static-site-generator seems like a nice thing. apart from the fiddling, it's meant to be a personal homepage for me. my real name is known to those whom it concerns ;) a legal notice (german: \"impressum\", which is mandatory here) will follow soon. I guess. This is/was the default vanilla mkdocs index page:","title":"Hi"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"what is this site? It's actually pretty much a garbage dump for stuff I often google but can't remember. Also it's a learning tree for templating, \"blogging\" and playing around with \"web\" stuff. I've heard that the average webpage these days is the size of the first \"doom\" game, so I'll try to help lowering that to a reasonable size again by setting up a website with little features and no content whatsoever. Should you be in the mood to complain, you can do so. Just replace \"complain\" with \"cheers\" and write to complain@gestos.de","title":"what is this?"},{"location":"about/#what-is-this-site","text":"It's actually pretty much a garbage dump for stuff I often google but can't remember. Also it's a learning tree for templating, \"blogging\" and playing around with \"web\" stuff. I've heard that the average webpage these days is the size of the first \"doom\" game, so I'll try to help lowering that to a reasonable size again by setting up a website with little features and no content whatsoever. Should you be in the mood to complain, you can do so. Just replace \"complain\" with \"cheers\" and write to complain@gestos.de","title":"what is this site?"},{"location":"blog/","text":"this is the blog main page, it is","title":"Blog"},{"location":"blogposts/2015-05-04-css-completion-in-vim/","text":":set omnifunc=csscomplete#CompleteCSS and the ctrl-x+ctrl-o will give the possible completions! see here and here the first one explains it very nicely and has a screenshot, too :-)","title":"css completion in vim"},{"location":"blogposts/2015-05-07-adjust-cursor-color-for-vim-and-urxvt/","text":"Whenever I used a dark colour scheme for vim (like the excellent muon or getafe , I find myself lost beacuse the usually black cursor of my urxvt wouldnt adjust to the dark colour theme. I found that this cant be tweaked in vim, but one can change the color of the urxvt terminal; so, for my needs, putting the following into $HOME/.Xresources: URxvt*cursorColor: #D6C0FB URxvt*cursorBlink: on does the job pretty satisfyingly :-) (for reloading the Xresources, use xrdb -load .Xresources. put the same command into ~/.xinitrc to have it loaded on X startup)","title":"adjust cursor color for vim and urxvt"},{"location":"blogposts/2015-05-15-mozilla-dekstop-download-directories/","text":"If you use Firefox or Iceweasel as I do, you may wonder about the \"Desktop\" and \"Download\" directories it creates every time you save anything to disk, even if you explicitly set ff to ask you where to save your stuff. This can be prevented by creating a ~/.config/user-dirs.dirs file, either with or without real content. This is according to http://www.kariliq.nl/misc/firefox-dirs.html and also this old arch forum post: https://bbs.archlinux.org/viewtopic.php?pid=997084#p997084","title":"Mozilla Dekstop Download Directories"},{"location":"blogposts/2016-11-01-printer/","text":"Network cups server up and running, avahi-systemd client also detecting the printer and printing fine on the gentoo client however, no networked printer is detected. Quic solution for now: localhost:631 (attention: somehow I added a line to one of the numerous config files around that made me go directly to the print server address) add printer. for the correct https uri I just visited the server's cups interface server:631 and copied the link to the printer in the admin section (just: copy link address. this seems to bet the valid resource format) when given the choice for a ppd filter, NOT choosing a ppd is the important part. cups offers a \"raw\" ppd / queue. Ust this, assuming the correct ppd is already given on the server side. -> works fine.","title":"network printer client side config"},{"location":"blogposts/Nebenzeiten_et_Agenten/","text":"This is a production notebook. It uses data gathered from a PBX and internal routing and will generate reports for TT, ACW and so on. It is meant to be customizeable, so one can easily adjust the time range that should be evaluated different plots are available for hotline data agent data call distribution The script can also easily iterate time ranges over the whole dataset and produce plots for each This script makes little sense to use from a CLI, it's meant to run in an IPython Environment script code a markdown dump straight out of the notebook: %load_ext autoreload %autoreload 2 ## Import necessary modules import os,sys import pandas as pd import matplotlib.pyplot as plt from matplotlib.dates import date2num, AutoDateFormatter, AutoDateLocator, WeekdayLocator, MonthLocator, DayLocator, DateLocator, DateFormatter from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU from matplotlib.ticker import AutoMinorLocator, AutoLocator, FormatStrFormatter, ScalarFormatter import numpy as np import datetime, calendar from datetime import timedelta import matplotlib.patches as mpatches from itertools import tee from traitlets import traitlets sys.path.append(os.path.abspath('/home/keuch/gits/keuch/code_box/pyt/spreadsheetparsing/entwuerfe/xls_testruns/lib/')) from ce_funclib import determine_kernzeit as dtkz from ce_funclib import continuity_check from ipywidgets import widgets, interact, interactive, fixed, interact_manual, Layout from IPython.display import display #%matplotlib inline %matplotlib tk ## Import data frome pickle generated from mu\u00df ein file mit agentenstats sein arcpth='/home/keuch/gits/keuch/code_box/pyt/spreadsheetparsing/test_stats/archiv/' ######## GET A LIST OF MATCHING .xls FILES FROM THE GIVEN DIRECTORY def collectxlfiles(arcpath): xlfilelist=list() for xlfile in os.listdir(arcpath): if xlfile.startswith('CE_alle_Ag'): xlfileabs=os.path.join(arcpath,xlfile) xlfilelist.append(xlfileabs) return sorted(xlfilelist) xlfilelist=collectxlfiles(arcpth) #xlfilelist #examplefile=xlfilelist[233] ###### TEST FOR DATA IN FILE, SORT OUT EMPTY FILES ## good dataframes do per definition not contain any zero values ## fill bad DFs with nan? def filetoframe(exfile): exframe=pd.read_excel(exfile) # this is a regular pd.DataFrame datecell=exframe.iloc[0,1] sheet_datetime=pd.to_datetime(datecell,format='%d.%m %Y : %H') sheet_date=sheet_datetime.date() integritycheck=exframe.iloc[2,1] # files with data have \"agenten\" here, files with no calls have a 'nan' if integritycheck != 'Agenten': # if it's empty, keep date for filling it later print('Exception: ', end='') except_status='ex' usefulcols={0:'tstamp',1:'agent',3:'an',4:'be',22:'vl',24:'ht_float',29:'tt_float'} # map cols to decent names exframe=exframe.reindex(columns=sorted(usefulcols.keys())) exframe.rename(columns=usefulcols,inplace=True) exframe=exframe[0:1] # strip text rows and the mangled sum row print(sheet_datetime) exframe['tstamp']=sheet_datetime exframe['date']=sheet_date exframe['agent']='nocalls_datum' exframe[['wd','ww','mm','yy']]=exframe['tstamp'].dt.strftime('%a,%W,%m,%Y').str.split(',',expand=True) # make ww,yy,mm,wd columns exframe['bz']=exframe['tstamp'].apply(dtkz) exframe['ort']=exframe['agent'].str[0] # split the identifier into useable columns exframe['id']='foobar' # split the identifier into useable columns # integers should be of appropriate datatype, we received them as strings # exframe[['vl','an','be','ww','mm','yy']]=exframe[['vl','an','be','ww','mm','yy']].astype(np.int64) #just for the beauty of it exframe.fillna(0, inplace=True) exframe[['ww','mm','yy']]=exframe[['ww','mm','yy']].astype(np.int64) #just for the beauty of it #exframe.fillna(0, inplace=True) return exframe,except_status else: except_status='reg' exframe.columns=range(0,30) # rename columns to a temporarily more readable format, fancy rename later usefulcols={0:'tstamp',1:'agent',3:'an',4:'be',22:'vl',24:'ht_float',29:'tt_float'} # map cols to decent names exframe=exframe[sorted(usefulcols.keys())] # skip cols and keep the ones we need exframe.rename(columns=usefulcols,inplace=True) # rename cols exframe=exframe[3:-1] # strip text rows and the mangled sum row exframe['tstamp']=pd.to_datetime(exframe['tstamp'],format=' %d.%m.%Y %H:%M ') exframe['date']=exframe['tstamp'].dt.date exframe[['wd','ww','mm','yy']]=exframe['tstamp'].dt.strftime('%a,%W,%m,%Y').str.split(',',expand=True) # make ww,yy,mm,wd columns exframe['bz']=exframe['tstamp'].apply(dtkz) exframe['ort']=exframe['agent'].str[0] # split the identifier into useable columns exframe['id']=exframe['agent'].str[-6:] # split the identifier into useable columns exframe['agent']=exframe['agent'].str[2:-7] # split the identifier into useable columns # integers should be of appropriate datatype, we received them as strings exframe[['vl','an','be','ww','mm','yy']]=exframe[['vl','an','be','ww','mm','yy']].astype(np.int64) #just for the beauty of it return exframe,except_status framelist=list() exceptionlist=list() for xfile in xlfilelist: frame_from_file,except_status=filetoframe(xfile) if except_status=='ex': exceptionlist.append(xfile) framelist.append(frame_from_file) Exception: 2017-04-17 00:00:00 Exception: 2017-05-14 00:00:00 Exception: 2017-11-19 00:00:00 Exception: 2017-12-03 00:00:00 Exception: 2017-12-10 00:00:00 Exception: 2018-03-04 00:00:00 Exception: 2018-03-11 00:00:00 Exception: 2018-04-08 00:00:00 #### produce a unified frame with all data and sort it by timstamp and agentname bigframeii=pd.concat(framelist) bigframeii.sort_values(['tstamp','agent'],inplace=True) bigframeii.reset_index(drop=True,inplace=True) # there you go # die exklusivlogins m\u00fcssen zusammengelegt werden unify_id={'gesinst':'995887','stanzju':'878457','papkeda':'891914'} bigframeii.loc[bigframeii['id'] == unify_id['gesinst'],'agent'] = 'gesinst' bigframeii.loc[bigframeii['id'] == unify_id['stanzju'],'agent'] = 'stanzju' bigframeii.loc[bigframeii['id'] == unify_id['papkeda'],'agent'] = 'papkeda' #### check, ob alle Daten(Tage) l\u00fcckenlos sind datenserie_uniq=bigframeii['date'].unique().tolist() tage_bestand=len(datenserie_uniq) tage_start=datenserie_uniq[0] tage_ende=datenserie_uniq[-1:] missing_dates=continuity_check(datenserie_uniq) if not missing_dates: print('no dates are missing') else: print('the following dates are not within the frame:') print(missing_dates) no dates are missing # get all agents available and create frames for kern and neben allagents_list=sorted(bigframeii['agent'].unique()) allagents_list.extend(['Hagenow','Berlin','Alle']) standorte=bigframeii.ort.unique().tolist() we can't figure out individual calls anyway, since raw data calls have been grouped by hours already so we can go on and group by days to figure out averages bigframeii.head(2) #Samstage = bigframeii.loc[(bigframeii['tstamp'].dt.dayofweek == 5) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } tstamp agent an be vl ht_float tt_float date wd ww mm yy bz ort id 0 2017-03-04 08:00:00 beckfra 1.0 1.0 0.0 2.3667 2.1333 2017-03-04 Sat 9 3 2017 n H 216694 1 2017-03-04 08:00:00 tetzlva 1.0 1.0 0.0 2.6833 2.6167 2017-03-04 Sat 9 3 2017 n B 613887 Datum_MIN = bigframeii.tstamp.dt.date.min() Datum_MAX = bigframeii.tstamp.dt.date.max() Datum_VON = datetime.date(2017,5,1) # YY,MM,DD Datum_BIS = datetime.date(2018,10,1) Kernzeit = (bigframeii['bz'] == 'k') Nebnzeit = (bigframeii['bz'] == 'n') Berlin = (bigframeii['ort'] == 'B') Hagenow = (bigframeii['ort'] == 'H') Wunschzeitraum = ((bigframeii.tstamp.dt.date >= Datum_VON) & (bigframeii.tstamp.dt.date <= Datum_BIS)) #bigframeii.loc[Wunschzeitraum & Kernzeit & Hagenow] # SUPER! kzdata=bigframeii.loc[Wunschzeitraum & Kernzeit].copy() kzdata_reindex=kzdata.set_index(['tstamp','ort']).copy() # timestamps und Standort als neue Indizes kzdata_byday=kzdata_reindex.groupby([pd.TimeGrouper('D', level='tstamp'), pd.Grouper(level='ort')]).sum() # nach Tagen gruppiert und alle Zahlen summiert def plotzi(frame): aht,aacw,att,nzb,bg =\"#003873\",\"#EE0042\",\"#899EB2\",\"#C7798F\",\"#FEFFE2\" sonntage=WeekdayLocator(byweekday=(6), interval=2) datevon=frame.index.get_level_values('tstamp').min().strftime('%d.%m.%y') datebis=frame.index.get_level_values('tstamp').max().strftime('%d.%m.%y') #### ------------------------------------ #### fig=plt.figure(figsize=(12,5)) ax=fig.add_subplot(111) ax.margins(0,0) ax.set_facecolor(bg) ax.set_xlabel('Kernzeit / ceDis von '+datevon+' bis '+datebis) ax.xaxis.set_major_locator(sonntage) ax.xaxis.set_major_formatter(DateFormatter('%d.%m.%y')) ax.set_ylabel('Calls angenommen') ber=frame.xs('B', level=1, drop_level=True)['an'] hgw=frame.xs('H', level=1, drop_level=True)['an'] b=ax.bar(ber.index,ber.values, label='calls', color=nzb, width=1) h=ax.bar(hgw.index,hgw.values, label='calls', color=aht, width=0.6) plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, horizontalalignment='right', size=6 ) bercalls=int(ber.sum()) hgwcalls=int(hgw.sum()) allecalls=bercalls+hgwcalls anteilhgw=str( format((hgwcalls/allecalls)*100,'.2f') ) anteilber=str( format((bercalls/allecalls)*100,'.2f') ) callsBH = mpatches.Patch(color='000000', label='Calls Ber+Hgw: '+str(allecalls)) callsB = mpatches.Patch(color=nzb, label='Calls Ber: '+str(bercalls) +' ('+anteilber+'%)' ) callsH = mpatches.Patch(color=aht, label='Calls Hgw: '+str(hgwcalls) +' ('+anteilhgw+'%)' ) ax.legend(handles=[callsBH,callsB,callsH],fontsize=8,ncol=2,loc='upper right',borderaxespad=-2,framealpha=0.99) plt.subplots_adjust(bottom=0.25) plotzi(kzdata_byday) example plots:","title":"matplotlib stat generator"},{"location":"blogposts/Nebenzeiten_et_Agenten/#script-code","text":"a markdown dump straight out of the notebook: %load_ext autoreload %autoreload 2 ## Import necessary modules import os,sys import pandas as pd import matplotlib.pyplot as plt from matplotlib.dates import date2num, AutoDateFormatter, AutoDateLocator, WeekdayLocator, MonthLocator, DayLocator, DateLocator, DateFormatter from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU from matplotlib.ticker import AutoMinorLocator, AutoLocator, FormatStrFormatter, ScalarFormatter import numpy as np import datetime, calendar from datetime import timedelta import matplotlib.patches as mpatches from itertools import tee from traitlets import traitlets sys.path.append(os.path.abspath('/home/keuch/gits/keuch/code_box/pyt/spreadsheetparsing/entwuerfe/xls_testruns/lib/')) from ce_funclib import determine_kernzeit as dtkz from ce_funclib import continuity_check from ipywidgets import widgets, interact, interactive, fixed, interact_manual, Layout from IPython.display import display #%matplotlib inline %matplotlib tk ## Import data frome pickle generated from mu\u00df ein file mit agentenstats sein arcpth='/home/keuch/gits/keuch/code_box/pyt/spreadsheetparsing/test_stats/archiv/' ######## GET A LIST OF MATCHING .xls FILES FROM THE GIVEN DIRECTORY def collectxlfiles(arcpath): xlfilelist=list() for xlfile in os.listdir(arcpath): if xlfile.startswith('CE_alle_Ag'): xlfileabs=os.path.join(arcpath,xlfile) xlfilelist.append(xlfileabs) return sorted(xlfilelist) xlfilelist=collectxlfiles(arcpth) #xlfilelist #examplefile=xlfilelist[233] ###### TEST FOR DATA IN FILE, SORT OUT EMPTY FILES ## good dataframes do per definition not contain any zero values ## fill bad DFs with nan? def filetoframe(exfile): exframe=pd.read_excel(exfile) # this is a regular pd.DataFrame datecell=exframe.iloc[0,1] sheet_datetime=pd.to_datetime(datecell,format='%d.%m %Y : %H') sheet_date=sheet_datetime.date() integritycheck=exframe.iloc[2,1] # files with data have \"agenten\" here, files with no calls have a 'nan' if integritycheck != 'Agenten': # if it's empty, keep date for filling it later print('Exception: ', end='') except_status='ex' usefulcols={0:'tstamp',1:'agent',3:'an',4:'be',22:'vl',24:'ht_float',29:'tt_float'} # map cols to decent names exframe=exframe.reindex(columns=sorted(usefulcols.keys())) exframe.rename(columns=usefulcols,inplace=True) exframe=exframe[0:1] # strip text rows and the mangled sum row print(sheet_datetime) exframe['tstamp']=sheet_datetime exframe['date']=sheet_date exframe['agent']='nocalls_datum' exframe[['wd','ww','mm','yy']]=exframe['tstamp'].dt.strftime('%a,%W,%m,%Y').str.split(',',expand=True) # make ww,yy,mm,wd columns exframe['bz']=exframe['tstamp'].apply(dtkz) exframe['ort']=exframe['agent'].str[0] # split the identifier into useable columns exframe['id']='foobar' # split the identifier into useable columns # integers should be of appropriate datatype, we received them as strings # exframe[['vl','an','be','ww','mm','yy']]=exframe[['vl','an','be','ww','mm','yy']].astype(np.int64) #just for the beauty of it exframe.fillna(0, inplace=True) exframe[['ww','mm','yy']]=exframe[['ww','mm','yy']].astype(np.int64) #just for the beauty of it #exframe.fillna(0, inplace=True) return exframe,except_status else: except_status='reg' exframe.columns=range(0,30) # rename columns to a temporarily more readable format, fancy rename later usefulcols={0:'tstamp',1:'agent',3:'an',4:'be',22:'vl',24:'ht_float',29:'tt_float'} # map cols to decent names exframe=exframe[sorted(usefulcols.keys())] # skip cols and keep the ones we need exframe.rename(columns=usefulcols,inplace=True) # rename cols exframe=exframe[3:-1] # strip text rows and the mangled sum row exframe['tstamp']=pd.to_datetime(exframe['tstamp'],format=' %d.%m.%Y %H:%M ') exframe['date']=exframe['tstamp'].dt.date exframe[['wd','ww','mm','yy']]=exframe['tstamp'].dt.strftime('%a,%W,%m,%Y').str.split(',',expand=True) # make ww,yy,mm,wd columns exframe['bz']=exframe['tstamp'].apply(dtkz) exframe['ort']=exframe['agent'].str[0] # split the identifier into useable columns exframe['id']=exframe['agent'].str[-6:] # split the identifier into useable columns exframe['agent']=exframe['agent'].str[2:-7] # split the identifier into useable columns # integers should be of appropriate datatype, we received them as strings exframe[['vl','an','be','ww','mm','yy']]=exframe[['vl','an','be','ww','mm','yy']].astype(np.int64) #just for the beauty of it return exframe,except_status framelist=list() exceptionlist=list() for xfile in xlfilelist: frame_from_file,except_status=filetoframe(xfile) if except_status=='ex': exceptionlist.append(xfile) framelist.append(frame_from_file) Exception: 2017-04-17 00:00:00 Exception: 2017-05-14 00:00:00 Exception: 2017-11-19 00:00:00 Exception: 2017-12-03 00:00:00 Exception: 2017-12-10 00:00:00 Exception: 2018-03-04 00:00:00 Exception: 2018-03-11 00:00:00 Exception: 2018-04-08 00:00:00 #### produce a unified frame with all data and sort it by timstamp and agentname bigframeii=pd.concat(framelist) bigframeii.sort_values(['tstamp','agent'],inplace=True) bigframeii.reset_index(drop=True,inplace=True) # there you go # die exklusivlogins m\u00fcssen zusammengelegt werden unify_id={'gesinst':'995887','stanzju':'878457','papkeda':'891914'} bigframeii.loc[bigframeii['id'] == unify_id['gesinst'],'agent'] = 'gesinst' bigframeii.loc[bigframeii['id'] == unify_id['stanzju'],'agent'] = 'stanzju' bigframeii.loc[bigframeii['id'] == unify_id['papkeda'],'agent'] = 'papkeda' #### check, ob alle Daten(Tage) l\u00fcckenlos sind datenserie_uniq=bigframeii['date'].unique().tolist() tage_bestand=len(datenserie_uniq) tage_start=datenserie_uniq[0] tage_ende=datenserie_uniq[-1:] missing_dates=continuity_check(datenserie_uniq) if not missing_dates: print('no dates are missing') else: print('the following dates are not within the frame:') print(missing_dates) no dates are missing # get all agents available and create frames for kern and neben allagents_list=sorted(bigframeii['agent'].unique()) allagents_list.extend(['Hagenow','Berlin','Alle']) standorte=bigframeii.ort.unique().tolist() we can't figure out individual calls anyway, since raw data calls have been grouped by hours already so we can go on and group by days to figure out averages bigframeii.head(2) #Samstage = bigframeii.loc[(bigframeii['tstamp'].dt.dayofweek == 5) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } tstamp agent an be vl ht_float tt_float date wd ww mm yy bz ort id 0 2017-03-04 08:00:00 beckfra 1.0 1.0 0.0 2.3667 2.1333 2017-03-04 Sat 9 3 2017 n H 216694 1 2017-03-04 08:00:00 tetzlva 1.0 1.0 0.0 2.6833 2.6167 2017-03-04 Sat 9 3 2017 n B 613887 Datum_MIN = bigframeii.tstamp.dt.date.min() Datum_MAX = bigframeii.tstamp.dt.date.max() Datum_VON = datetime.date(2017,5,1) # YY,MM,DD Datum_BIS = datetime.date(2018,10,1) Kernzeit = (bigframeii['bz'] == 'k') Nebnzeit = (bigframeii['bz'] == 'n') Berlin = (bigframeii['ort'] == 'B') Hagenow = (bigframeii['ort'] == 'H') Wunschzeitraum = ((bigframeii.tstamp.dt.date >= Datum_VON) & (bigframeii.tstamp.dt.date <= Datum_BIS)) #bigframeii.loc[Wunschzeitraum & Kernzeit & Hagenow] # SUPER! kzdata=bigframeii.loc[Wunschzeitraum & Kernzeit].copy() kzdata_reindex=kzdata.set_index(['tstamp','ort']).copy() # timestamps und Standort als neue Indizes kzdata_byday=kzdata_reindex.groupby([pd.TimeGrouper('D', level='tstamp'), pd.Grouper(level='ort')]).sum() # nach Tagen gruppiert und alle Zahlen summiert def plotzi(frame): aht,aacw,att,nzb,bg =\"#003873\",\"#EE0042\",\"#899EB2\",\"#C7798F\",\"#FEFFE2\" sonntage=WeekdayLocator(byweekday=(6), interval=2) datevon=frame.index.get_level_values('tstamp').min().strftime('%d.%m.%y') datebis=frame.index.get_level_values('tstamp').max().strftime('%d.%m.%y') #### ------------------------------------ #### fig=plt.figure(figsize=(12,5)) ax=fig.add_subplot(111) ax.margins(0,0) ax.set_facecolor(bg) ax.set_xlabel('Kernzeit / ceDis von '+datevon+' bis '+datebis) ax.xaxis.set_major_locator(sonntage) ax.xaxis.set_major_formatter(DateFormatter('%d.%m.%y')) ax.set_ylabel('Calls angenommen') ber=frame.xs('B', level=1, drop_level=True)['an'] hgw=frame.xs('H', level=1, drop_level=True)['an'] b=ax.bar(ber.index,ber.values, label='calls', color=nzb, width=1) h=ax.bar(hgw.index,hgw.values, label='calls', color=aht, width=0.6) plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, horizontalalignment='right', size=6 ) bercalls=int(ber.sum()) hgwcalls=int(hgw.sum()) allecalls=bercalls+hgwcalls anteilhgw=str( format((hgwcalls/allecalls)*100,'.2f') ) anteilber=str( format((bercalls/allecalls)*100,'.2f') ) callsBH = mpatches.Patch(color='000000', label='Calls Ber+Hgw: '+str(allecalls)) callsB = mpatches.Patch(color=nzb, label='Calls Ber: '+str(bercalls) +' ('+anteilber+'%)' ) callsH = mpatches.Patch(color=aht, label='Calls Hgw: '+str(hgwcalls) +' ('+anteilhgw+'%)' ) ax.legend(handles=[callsBH,callsB,callsH],fontsize=8,ncol=2,loc='upper right',borderaxespad=-2,framealpha=0.99) plt.subplots_adjust(bottom=0.25) plotzi(kzdata_byday)","title":"script code"},{"location":"blogposts/Nebenzeiten_et_Agenten/#example-plots","text":"","title":"example plots:"},{"location":"blogposts/eliqrechner/","text":"Hier ist ein E-Liquid-Rechner So was gibt's anderswo schon fast genausogut ;), aber der hiesige ist f\u00fcr meine Bed\u00fcrfnisse angepasst.","title":"E-Liquid Calculator"},{"location":"blogposts/playlist_normalize/","text":"this script will read the file locations from a playlist and create a new timestamp-named folder either in a specified location or the users $HOME path copy the mp3 files to the newly created folder set all files to the same volume level write a new playlist of relative pathnames to the directory setting the volume is done by way of mp3gain 's \"-r\" and \"-d\" flag. Afaics the default base value would be 89db, so mp3gain -r -d6 would be equal to 89db +6db = 95db script #!/bin/bash OLDIFS=$IFS IFS=' ' printf \"looking for mp3gain... \" command -v mp3gain || (printf \"this script depends on mp3gain, which is not present on this computer. exiting\\n\" && exit 0) if [[ -z $@ ]]; then echo \"usage: pass a playlist as first parameter and a destination basepath as optional second parameter\" && exit 1 fi defaultdir=$HOME arg1=$(file -b $1) arg2=$(file -b ${2:-$HOME}) colr='\\033[0;34m' off='\\033[0m' if [[ ( ${arg1,,} != *playlist* ) || ( ${arg1,,} == error* ) ]]; then echo \"please pass a valid playlist as first argument\" exit 1 fi if [[ -z $2 ]]; then echo \"you can specify a destination path as second parameter... defaulting to ${HOME}\" fi pllist=$(/usr/bin/basename $1) tstamp=$(date +%Y_%j_%H%M%S) destpth=${2:-$HOME} destin=${destpth%/}/00_playlists_normalized/\"${pllist%.*}\"-\"${tstamp}\" read -n 1 -p $'normalize \\e[34m'\"${1}\"$'\\e[0m'\" in \"$'\\e[34m'\"${destin}\"$'\\e[0m'\" [y/n]\" yn case \"$yn\" in [Yy] ) printf \"\\n\";; * ) printf \"\\n\" && exit 0;; esac printf \"creating a destination directory at ${colr}${destin}${off}... \" mkdir -p $destin && printf \"ok\\n\" printf \"copying files to ${colr}${destin}${off}...\" for mp3_file in $(grep \"^[^#]\" $1 | sed 's/\\r$//'); do cp $mp3_file $destin; done && printf \"ok\\n\" printf \"${colr}applying uniform gain${off}\\n\" mp3gain -r -c -k ${destin}/*mp3 printf \"rewriting playlist for normalized directory to${colr}${destin}/playlist_${tstamp}.m3u${off}...\\n\" for i in $(grep \"^[^#]\" $1); do echo ${i##/*/} >> $destin/playlist_${tstamp}.m3u; done && printf \"ok \\n\" IFS=$OLDIFS save as","title":"playlist-converter"},{"location":"blogposts/playlist_normalize/#script","text":"#!/bin/bash OLDIFS=$IFS IFS=' ' printf \"looking for mp3gain... \" command -v mp3gain || (printf \"this script depends on mp3gain, which is not present on this computer. exiting\\n\" && exit 0) if [[ -z $@ ]]; then echo \"usage: pass a playlist as first parameter and a destination basepath as optional second parameter\" && exit 1 fi defaultdir=$HOME arg1=$(file -b $1) arg2=$(file -b ${2:-$HOME}) colr='\\033[0;34m' off='\\033[0m' if [[ ( ${arg1,,} != *playlist* ) || ( ${arg1,,} == error* ) ]]; then echo \"please pass a valid playlist as first argument\" exit 1 fi if [[ -z $2 ]]; then echo \"you can specify a destination path as second parameter... defaulting to ${HOME}\" fi pllist=$(/usr/bin/basename $1) tstamp=$(date +%Y_%j_%H%M%S) destpth=${2:-$HOME} destin=${destpth%/}/00_playlists_normalized/\"${pllist%.*}\"-\"${tstamp}\" read -n 1 -p $'normalize \\e[34m'\"${1}\"$'\\e[0m'\" in \"$'\\e[34m'\"${destin}\"$'\\e[0m'\" [y/n]\" yn case \"$yn\" in [Yy] ) printf \"\\n\";; * ) printf \"\\n\" && exit 0;; esac printf \"creating a destination directory at ${colr}${destin}${off}... \" mkdir -p $destin && printf \"ok\\n\" printf \"copying files to ${colr}${destin}${off}...\" for mp3_file in $(grep \"^[^#]\" $1 | sed 's/\\r$//'); do cp $mp3_file $destin; done && printf \"ok\\n\" printf \"${colr}applying uniform gain${off}\\n\" mp3gain -r -c -k ${destin}/*mp3 printf \"rewriting playlist for normalized directory to${colr}${destin}/playlist_${tstamp}.m3u${off}...\\n\" for i in $(grep \"^[^#]\" $1); do echo ${i##/*/} >> $destin/playlist_${tstamp}.m3u; done && printf \"ok \\n\" IFS=$OLDIFS save as","title":"script"},{"location":"blogposts/print_margins/","text":"besides the css settings, firefox will need to be adjusted if one wants to use the full area of an A4 paper sheet. this mozilla blog post is in the right direction, but there's a third configuration options for the margins called print.print_edge , see screenshot: of course, the same options shown here for bottom can be set for top , left and right as well. it seems like the relevant options are the print.print_unwriteable_margin_ options, but that may depend on which printer you select for the print preview. There seems to be no well-structured mozilla authorized manual for this stuff and I'm too lazy to dig deeper into it right now. setting all of those to zero will give you the full page for printing, but will also remove the page count in the formerly \"unwriteable\" top right corner. more mozilla on this topic since I don't want the page counter removed just for the one use case that I'm fiddling with, I set the top margin to 20. The numbers seem to refer to the percenteage of an inch (see link above). I checked manually, the counter won't appear below a top margin of 20, which seems stupid, because it will respect that margin, leaving blank margin to the page edge... Also, I changed the A4 width + height settings in my css to a value slightly lower than standard (200mm instead of 210mm width, 290mm instead of 297mm height). The \"real\" standard measurements seem to cause a page break even with all margins set to zero. Using these slightly smaller values however works ok.","title":"printmargins"},{"location":"new_section/some_shell_tips/","text":"gnu screen caption line and scrolling while I'm revisiting my shell and screen startup files, I try to solve a thing that I always found annoying but never bothered to look it up. First, a look at my .screenrc file: startup_message off # no welcome message when screen starts shell $SHELL # start bash as a non-login shell (shell -$SHELL would start a login shell) shelltitle \"$ |bash\" # show name of currently running program as title in the terminal attrcolor b \".I\" # I really don't know anymore defhstatus \"(^Et) | $USER@^EH\" # show name of current program in window list hardstatus off # suppress status messages (\"bell in window 0\") caption always \"%{= wk} %-w%{= KW} [%n %t ] %{-}%+w %= %{= wg} %C%a\" # generates a status line at the bottom of the window bindkey \"^[Od\" prev # ctrl-left moves to previous window bindkey \"^[Oc\" next # ctrl-right moves to next window term screen-256color # gives access to all colors on 256-color terminals termcapinfo xterm* ti@:te@ # this enables using the scrollbar of the terminal window and mouse scrolling with this configuration, I can scroll up the terminal window (eg to view some output), but whenever the time in the caption changes, the scroll buffer will return to the bottom of the terminal because of the change in the caption line to avoid this, one can use screens \"copy mode\". The caption will stay in the foreground, while you can use the arrow keys to move up and down through the terminal output. Ctrl+A Esc to go in copy mode. Then use arrows or PageUp/PageDown to move through the scroll buffer. To exit copy mode, just hit Esc. copy mode tip from TeChn4K/superuser explanations for all screenrc commands can be found at aperiodic very useful blogpost for understanding the caption/hardstatus strings at kilobitspersecond dircolors and environment sourcing Since I rarely have an editor instance opened indirectly via the system's environment, I found out by chance that my $EDITOR variable was set to /usr/bin/nano instead of /usr/bin/vim . So I wanted to find out, where that variable was sourced from. In this case, I'm working on a systemd-free gentoo machine and apparently the common way to set default environment variables in gentoo is putting an appropriate file into /etc/env.d/ . So, grep -ir editor /etc/env.d/ should either come up with a file that can be edited to the appropriate value or one can create a new file. Files are numbered, which determines the order in which they'll be read. So in this case, I created /etc/env.d/99editor , containing only one line that says EDITOR=\"/usr/bin/vim\" . To merge this change into your $ENV, you'll need to run env-update and it will be written to /etc/profile.env . Now, to have a detailed look into $ENV and find out which variables get sourced from where and when, I found a most useful tip from Stephane Chazelas on stackexchange. Running PS4='+$BASH_SOURCE> ' BASH_XTRACEFD=7 bash -xl 7>&2 will tell you in all detail in which order the environment is sourced and which files set which variables. It's also a good occasion to read up again on the various .bashrc, .bash_profile, /etc/profile and what have you other files that are involved in the shell environment buildup. Of course I didn't ;). But while I'm at it I want to get rid of the annoying default DIRCOLS that don't mix with my terminal background at last... As equery u rxvt-unicode tells me: * Found these USE flags for x11-terms/rxvt-unicode-9.21: U I + + 256-color : Enable 256 color support that I have 256 colors, I should at least use some of those that can be read from a light background. So, first thing to do: go to FLOZz , save and run that script (and of course grok all the nice info he has on terminal colours). next dircolors -p > ~/.dir_colors (filename is arbitrary) to create a file that you can modify and which will be sourced into $ENV in the future. edit the file to your liking. I found seebis solarized dircolors somewhat instructional. The notation for 256 colors differs from the standard shell escape codes. The notation is for example 00;38;5;34 or 01;48;5;255 where: 00; or 01; is for normal or bold 38; or 48; is for foreground or background 5; (don't really know, probably the identifier for the 256-colorscheme) the last number is the actual colour code as displayed by FLOZz's script once the editing is done execute eval \"$(dircolors -b ~/.dir_colors)\" to have bash use the new colours. To make this permanent, put that command in one of the environment files (see above links to read up which one suites best... I've put it into ~/.bashrc which in turn is sourced by ~/.bash_profile). As I don't like coloured file extensions but care only about the files with special permissions, my ~/.dir_colors looks pretty dull: Configuration file for dircolors, a utility to help you set the LS_COLORS environment variable used by GNU ls with the --color option. Copyright (C) 1996-2017 Free Software Foundation, Inc. Copying and distribution of this file, with or without modification, are permitted provided the copyright notice and this notice are preserved. TERM Eterm TERM ansi TERM *color* TERM con[0-9]*x[0-9]* TERM cons25 TERM console TERM cygwin TERM dtterm TERM gnome TERM hurd TERM jfbterm TERM konsole TERM kterm TERM linux TERM linux-c TERM mlterm TERM putty TERM rxvt* TERM screen* TERM st TERM terminator TERM tmux* TERM vt100 TERM xterm* NORMAL 00 # no color code at all FILE 00 # regular file: use no color at all RESET 0 # reset to \"normal\" color DIR 01;38;5;26 # directory LINK 01;36 # symbolic link. (If you set this to 'target' instead of a # numerical value, the color is as for the file pointed to.) MULTIHARDLINK 00 # regular file with more than one link FIFO 40;33 # pipe SOCK 01;35 # socket DOOR 01;35 # door BLK 40;33;01 # block device driver CHR 40;33;01 # character device driver ORPHAN 01;05;37;41 # symlink to nonexistent file, or non-stat'able file ... MISSING 01;05;37;41 # ... and the files they point to SETUID 37;41 # file that is setuid (u+s) SETGID 30;43 # file that is setgid (g+s) CAPABILITY 30;41 # file with capability STICKY_OTHER_WRITABLE 30;42 # dir that is sticky and other-writable (+t,o+w) OTHER_WRITABLE 34;42 # dir that is other-writable (o+w) and not sticky STICKY 37;44 # dir with the sticky bit set (+t) and not other-writable This is for files with execute permission: EXEC 00;38;5;34 Or if you want to colorize scripts even if they do not have the executable bit actually set. .sh 01;32 .csh 01;32 Links: gentoo handbook: environment variables ubuntu manpages 1 , 5","title":"some shell tips"},{"location":"new_section/some_shell_tips/#gnu-screen-caption-line-and-scrolling","text":"while I'm revisiting my shell and screen startup files, I try to solve a thing that I always found annoying but never bothered to look it up. First, a look at my .screenrc file: startup_message off # no welcome message when screen starts shell $SHELL # start bash as a non-login shell (shell -$SHELL would start a login shell) shelltitle \"$ |bash\" # show name of currently running program as title in the terminal attrcolor b \".I\" # I really don't know anymore defhstatus \"(^Et) | $USER@^EH\" # show name of current program in window list hardstatus off # suppress status messages (\"bell in window 0\") caption always \"%{= wk} %-w%{= KW} [%n %t ] %{-}%+w %= %{= wg} %C%a\" # generates a status line at the bottom of the window bindkey \"^[Od\" prev # ctrl-left moves to previous window bindkey \"^[Oc\" next # ctrl-right moves to next window term screen-256color # gives access to all colors on 256-color terminals termcapinfo xterm* ti@:te@ # this enables using the scrollbar of the terminal window and mouse scrolling with this configuration, I can scroll up the terminal window (eg to view some output), but whenever the time in the caption changes, the scroll buffer will return to the bottom of the terminal because of the change in the caption line to avoid this, one can use screens \"copy mode\". The caption will stay in the foreground, while you can use the arrow keys to move up and down through the terminal output. Ctrl+A Esc to go in copy mode. Then use arrows or PageUp/PageDown to move through the scroll buffer. To exit copy mode, just hit Esc. copy mode tip from TeChn4K/superuser explanations for all screenrc commands can be found at aperiodic very useful blogpost for understanding the caption/hardstatus strings at kilobitspersecond","title":"gnu screen caption line and scrolling"},{"location":"new_section/some_shell_tips/#dircolors-and-environment-sourcing","text":"Since I rarely have an editor instance opened indirectly via the system's environment, I found out by chance that my $EDITOR variable was set to /usr/bin/nano instead of /usr/bin/vim . So I wanted to find out, where that variable was sourced from. In this case, I'm working on a systemd-free gentoo machine and apparently the common way to set default environment variables in gentoo is putting an appropriate file into /etc/env.d/ . So, grep -ir editor /etc/env.d/ should either come up with a file that can be edited to the appropriate value or one can create a new file. Files are numbered, which determines the order in which they'll be read. So in this case, I created /etc/env.d/99editor , containing only one line that says EDITOR=\"/usr/bin/vim\" . To merge this change into your $ENV, you'll need to run env-update and it will be written to /etc/profile.env . Now, to have a detailed look into $ENV and find out which variables get sourced from where and when, I found a most useful tip from Stephane Chazelas on stackexchange. Running PS4='+$BASH_SOURCE> ' BASH_XTRACEFD=7 bash -xl 7>&2 will tell you in all detail in which order the environment is sourced and which files set which variables. It's also a good occasion to read up again on the various .bashrc, .bash_profile, /etc/profile and what have you other files that are involved in the shell environment buildup. Of course I didn't ;). But while I'm at it I want to get rid of the annoying default DIRCOLS that don't mix with my terminal background at last... As equery u rxvt-unicode tells me: * Found these USE flags for x11-terms/rxvt-unicode-9.21: U I + + 256-color : Enable 256 color support that I have 256 colors, I should at least use some of those that can be read from a light background. So, first thing to do: go to FLOZz , save and run that script (and of course grok all the nice info he has on terminal colours). next dircolors -p > ~/.dir_colors (filename is arbitrary) to create a file that you can modify and which will be sourced into $ENV in the future. edit the file to your liking. I found seebis solarized dircolors somewhat instructional. The notation for 256 colors differs from the standard shell escape codes. The notation is for example 00;38;5;34 or 01;48;5;255 where: 00; or 01; is for normal or bold 38; or 48; is for foreground or background 5; (don't really know, probably the identifier for the 256-colorscheme) the last number is the actual colour code as displayed by FLOZz's script once the editing is done execute eval \"$(dircolors -b ~/.dir_colors)\" to have bash use the new colours. To make this permanent, put that command in one of the environment files (see above links to read up which one suites best... I've put it into ~/.bashrc which in turn is sourced by ~/.bash_profile). As I don't like coloured file extensions but care only about the files with special permissions, my ~/.dir_colors looks pretty dull: Configuration file for dircolors, a utility to help you set the LS_COLORS environment variable used by GNU ls with the --color option. Copyright (C) 1996-2017 Free Software Foundation, Inc. Copying and distribution of this file, with or without modification, are permitted provided the copyright notice and this notice are preserved. TERM Eterm TERM ansi TERM *color* TERM con[0-9]*x[0-9]* TERM cons25 TERM console TERM cygwin TERM dtterm TERM gnome TERM hurd TERM jfbterm TERM konsole TERM kterm TERM linux TERM linux-c TERM mlterm TERM putty TERM rxvt* TERM screen* TERM st TERM terminator TERM tmux* TERM vt100 TERM xterm* NORMAL 00 # no color code at all FILE 00 # regular file: use no color at all RESET 0 # reset to \"normal\" color DIR 01;38;5;26 # directory LINK 01;36 # symbolic link. (If you set this to 'target' instead of a # numerical value, the color is as for the file pointed to.) MULTIHARDLINK 00 # regular file with more than one link FIFO 40;33 # pipe SOCK 01;35 # socket DOOR 01;35 # door BLK 40;33;01 # block device driver CHR 40;33;01 # character device driver ORPHAN 01;05;37;41 # symlink to nonexistent file, or non-stat'able file ... MISSING 01;05;37;41 # ... and the files they point to SETUID 37;41 # file that is setuid (u+s) SETGID 30;43 # file that is setgid (g+s) CAPABILITY 30;41 # file with capability STICKY_OTHER_WRITABLE 30;42 # dir that is sticky and other-writable (+t,o+w) OTHER_WRITABLE 34;42 # dir that is other-writable (o+w) and not sticky STICKY 37;44 # dir with the sticky bit set (+t) and not other-writable This is for files with execute permission: EXEC 00;38;5;34 Or if you want to colorize scripts even if they do not have the executable bit actually set. .sh 01;32 .csh 01;32 Links: gentoo handbook: environment variables ubuntu manpages 1 , 5","title":"dircolors and environment sourcing"},{"location":"blog/","text":"holy fuck god damn shit motherfucker tou -fucking- rette , bitch","title":"Blog"}]}